<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Underfloor Guardians</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
            touch-action: none;
        }
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #gameStatus {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            display: none;
        }
        #startButton {
            margin-top: 15px;
            padding: 10px 20px;
            font-size: 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #debugInfo {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 12px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
            z-index: 150;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="hud">
            <div id="humanCount">人: 1</div>
            <div id="timer">時間: 0s</div>
        </div>
        <div id="gameStatus" style="display: none;">
            <div id="statusText">ゲーム開始</div>
            <button id="startButton">スタート</button>
        </div>
        <div id="debugInfo">
            <div>デバッグ情報:</div>
            <div id="debugText">初期化中...</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ゲーム状態
        let scene, camera, renderer;
        let gameState = 'menu'; // 'menu', 'playing', 'win', 'lose'
        let gameTime = 0;
        let gameRunning = false;

        // ゲームエンティティ
        let humans = [];
        let zombies = [];
        let effects = [];
        let debugLines = []; // デバッグライン用
        let currentStage = 1;
        let entrances = [];
        let exits = [];
        let lastExitInfo = null; // 前のステージの出口情報
        let pathLines = []; // パス表示用

        // ゲーム設定
        const FIELD_SIZE = 35; // エリアを拡大
        const HUMAN_SPEED = 1.5;
        const ZOMBIE_SPEED = 1.0;
        const ZOMBIE_DOWN_TIME = 2.0;
        const TAP_RADIUS = 4.0;
        const CONTACT_TIME_LIMIT = 1.0; // 接触判定時間（秒）
        const CONTACT_DISTANCE = 1.0; // 接触判定距離
        const ZOMBIE_DETECTION_RANGE = 20.0; // ゾンビの人検知範囲（遠くから見渡す）
        const HUMAN_AVOIDANCE_RANGE = 6.0; // 人の回避範囲
        const ZOMBIE_ROTATION_SPEED = 4.0; // ゾンビの回転速度
        const ENTRANCE_SIZE = 3.0; // 入口のサイズ
        const EXIT_SIZE = 3.0; // 出口のサイズ

        // 床下カメラの初期化
        function initCamera() {
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // 床下から見上げる視点（Y軸を反転）
            camera.position.set(0, -30, 0); // カメラを遠くに移動
            camera.lookAt(0, 0, 0);
            camera.up.set(0, 0, 1); // Z軸を上方向に設定
            console.log('カメラ初期化完了:', camera.position);
        }

        // シーンの初期化
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            // 環境光の追加
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            // 方向光の追加
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(-1, 1, 1);
            scene.add(directionalLight);

            // 床グリッドの作成
            const gridHelper = new THREE.GridHelper(FIELD_SIZE, FIELD_SIZE, 0x444444, 0x222222);
            gridHelper.material.transparent = true;
            gridHelper.material.opacity = 0.6;
            gridHelper.name = 'ground'; // 床に名前を付ける
            scene.add(gridHelper);

            // 実際の床面（クリック判定用）
            const floorGeometry = new THREE.PlaneGeometry(FIELD_SIZE, FIELD_SIZE);
            const floorMaterial = new THREE.MeshBasicMaterial({
                transparent: true,
                opacity: 0.01,
                color: 0x000000
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.name = 'ground';
            scene.add(floor);

            // 境界壁の作成
            const wallMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x666666, 
                transparent: true, 
                opacity: 0.3 
            });
            
            // 4つの壁を作成
            const wallHeight = 2;
            const wallThickness = 0.5;
            
            const walls = [
                { pos: [0, wallHeight/2, FIELD_SIZE/2], size: [FIELD_SIZE, wallHeight, wallThickness] },
                { pos: [0, wallHeight/2, -FIELD_SIZE/2], size: [FIELD_SIZE, wallHeight, wallThickness] },
                { pos: [FIELD_SIZE/2, wallHeight/2, 0], size: [wallThickness, wallHeight, FIELD_SIZE] },
                { pos: [-FIELD_SIZE/2, wallHeight/2, 0], size: [wallThickness, wallHeight, FIELD_SIZE] }
            ];

            walls.forEach(wall => {
                const geometry = new THREE.BoxGeometry(...wall.size);
                const mesh = new THREE.Mesh(geometry, wallMaterial);
                mesh.position.set(...wall.pos);
                scene.add(mesh);
            });

            // 入口と出口を生成
            generateEntrancesAndExits();
        }

        // レンダラーの初期化
        function initRenderer() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);
        }

        // 対向する壁を取得
        function getOppositeWall(wall) {
            const opposites = {
                'north': 'south',
                'south': 'north',
                'east': 'west',
                'west': 'east'
            };
            return opposites[wall];
        }

        // 入口と出口の生成
        function generateEntrancesAndExits() {
            console.log('新しい部屋を生成中... ステージ', currentStage);
            entrances = [];
            exits = [];
            
            // 全ての壁
            const allWalls = ['north', 'south', 'east', 'west'];
            
            let entrance;
            let entranceWall;
            
            if (lastExitInfo && currentStage > 1) {
                // 前のステージの出口情報から隣の部屋の入口を計算
                entranceWall = getOppositeWall(lastExitInfo.wall);
                entrance = createDoorOnWall(entranceWall, lastExitInfo.position);
                console.log('前の出口から入口生成:', lastExitInfo.wall, '→', entranceWall, 'at', lastExitInfo.position);
            } else {
                // 初回はランダム
                entranceWall = allWalls[Math.floor(Math.random() * allWalls.length)];
                entrance = createDoorOnWall(entranceWall);
                console.log('ランダム入口生成:', entranceWall);
            }
            entrance.type = 'entrance';
            entrances.push(entrance);
            
            // 入口エリアの視覚化（床面）
            const entranceGeometry = new THREE.CircleGeometry(ENTRANCE_SIZE, 16);
            const entranceMaterial = new THREE.MeshBasicMaterial({
                color: 0x0099ff,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const entranceMesh = new THREE.Mesh(entranceGeometry, entranceMaterial);
            entranceMesh.position.set(entrance.x, 0.2, entrance.z);
            entranceMesh.rotation.x = -Math.PI / 2;
            entranceMesh.userData.removable = true;
            scene.add(entranceMesh);
            console.log('入口エリア作成:', entrance.x, entrance.z);
            
            // 出口を生成（入口以外の壁からランダム選択、最大2個）
            const availableWalls = allWalls.filter(wall => wall !== entranceWall);
            const numExits = Math.floor(Math.random() * 2) + 1; // 1つまたは2つの出口
            console.log('出口数:', numExits, '利用可能な壁:', availableWalls);
            
            const minDistance = 15; // 入口と出口の最小距離
            let attempts = 0;
            const maxAttempts = 20;
            
            for (let i = 0; i < numExits && availableWalls.length > 0 && attempts < maxAttempts; i++) {
                const wallIndex = Math.floor(Math.random() * availableWalls.length);
                const selectedWall = availableWalls[wallIndex];
                console.log('出口', i+1, '壁選択:', selectedWall);
                
                const exit = createDoorOnWall(selectedWall);
                exit.type = 'exit';
                
                // 入口との距離をチェック
                const distanceToEntrance = Math.sqrt(
                    (exit.x - entrance.x) * (exit.x - entrance.x) +
                    (exit.z - entrance.z) * (exit.z - entrance.z)
                );
                
                if (distanceToEntrance >= minDistance) {
                    exits.push(exit);
                    availableWalls.splice(wallIndex, 1); // 使用済み壁を削除
                    
                    // 出口エリアの視覚化（床面）
                    const exitGeometry = new THREE.CircleGeometry(EXIT_SIZE, 16);
                    const exitMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00ff00,
                        transparent: true,
                        opacity: 0.8,
                        side: THREE.DoubleSide
                    });
                    const exitMesh = new THREE.Mesh(exitGeometry, exitMaterial);
                    exitMesh.position.set(exit.x, 0.2, exit.z);
                    exitMesh.rotation.x = -Math.PI / 2;
                    exitMesh.userData.removable = true;
                    scene.add(exitMesh);
                    console.log('出口エリア作成:', exit.x, exit.z, '距離:', distanceToEntrance.toFixed(1));
                } else {
                    console.log('出口却下（距離不足）:', distanceToEntrance.toFixed(1), '<', minDistance);
                    i--; // やり直し
                }
                attempts++;
            }
            
            console.log('入口:', entrances);
            console.log('出口:', exits);
        }

        // 指定された壁にドアを作成
        function createDoorOnWall(wall, position = null) {
            let door;
            const margin = 4; // 壁の端からの余白
            
            // positionが指定されている場合はそれを使用、なければランダム
            const pos = position !== null ? position : (Math.random() - 0.5) * (FIELD_SIZE - margin * 2);
            
            switch (wall) {
                case 'north':
                    door = {
                        x: pos,
                        z: FIELD_SIZE/2 - 2,
                        wall: 'north'
                    };
                    break;
                case 'south':
                    door = {
                        x: pos,
                        z: -FIELD_SIZE/2 + 2,
                        wall: 'south'
                    };
                    break;
                case 'east':
                    door = {
                        x: FIELD_SIZE/2 - 2,
                        z: pos,
                        wall: 'east'
                    };
                    break;
                case 'west':
                    door = {
                        x: -FIELD_SIZE/2 + 2,
                        z: pos,
                        wall: 'west'
                    };
                    break;
            }
            console.log('ドア作成:', wall, 'at', door.x.toFixed(1), door.z.toFixed(1));
            return door;
        }

        // 最も近い出口を見つける
        function findNearestExit(x, z) {
            let nearestExit = null;
            let nearestDistance = Infinity;
            
            exits.forEach(exit => {
                const dx = exit.x - x;
                const dz = exit.z - z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance < nearestDistance) {
                    nearestDistance = distance;
                    nearestExit = exit;
                }
            });
            
            return nearestExit;
        }

        // 球体メッシュの作成
        function createEntityMesh(color) {
            const geometry = new THREE.SphereGeometry(0.6, 16, 12);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.y = 1.0;
            
            console.log('エンティティメッシュ作成:', color.toString(16));
            return mesh;
        }

        // 人の作成
        function createHuman(x, z) {
            const nearestExit = findNearestExit(x, z);
            const human = {
                mesh: createEntityMesh(0x0066ff),
                x: x,
                z: z,
                targetX: nearestExit ? nearestExit.x : 0,
                targetZ: nearestExit ? nearestExit.z : 0,
                currentTarget: nearestExit,
                speed: HUMAN_SPEED,
                alive: true,
                contactTimer: 0, // 接触タイマー
                direction: 0, // 進行方向（ラジアン）
                currentPath: [], // 現在の経路
                pathIndex: 0, // 経路上の現在位置
                pathUpdateTimer: 0 // 経路更新タイマー
            };
            human.mesh.position.set(x, 1.0, z);
            scene.add(human.mesh);
            console.log('人を作成:', x, z, '→ 出口:', human.targetX, human.targetZ);
            return human;
        }

        // ゾンビの作成
        function createZombie(x, z) {
            const zombie = {
                mesh: createEntityMesh(0xff0000),
                x: x,
                z: z,
                speed: ZOMBIE_SPEED,
                state: 'wandering', // 'wandering', 'rotating', 'chasing', 'down'
                downTimer: 0,
                target: null,
                direction: Math.random() * Math.PI * 2, // 現在の方向
                targetDirection: 0, // 目標方向
                rotationDirection: 1, // 回転方向 (1 or -1)
                contactTimer: 0, // 接触タイマー
                wanderTimer: 0 // ランダム移動タイマー
            };
            zombie.mesh.position.set(x, 1.0, z);
            scene.add(zombie.mesh);
            console.log('ゾンビを作成:', x, z);
            return zombie;
        }

        // エフェクトの作成（タップ時の波紋）
        function createRippleEffect(x, z) {
            const effect = {
                mesh: null,
                x: x,
                z: z,
                radius: 0,
                maxRadius: TAP_RADIUS,
                life: 1.0,
                maxLife: 1.0
            };

            const geometry = new THREE.RingGeometry(0.1, TAP_RADIUS, 32);
            const material = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            effect.mesh = new THREE.Mesh(geometry, material);
            effect.mesh.position.set(x, 0.1, z);
            effect.mesh.rotation.x = -Math.PI / 2;
            scene.add(effect.mesh);

            effects.push(effect);
        }

        // デバッグライン作成
        function createDebugLine(startX, startZ, endX, endZ, color) {
            const points = [];
            points.push(new THREE.Vector3(startX, 1.5, startZ));
            points.push(new THREE.Vector3(endX, 1.5, endZ));
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.8 });
            const line = new THREE.Line(geometry, material);
            
            scene.add(line);
            debugLines.push(line);
        }

        // デバッグラインをクリア
        function clearDebugLines() {
            debugLines.forEach(line => scene.remove(line));
            debugLines = [];
        }

        // パスラインをクリア
        function clearPathLines() {
            pathLines.forEach(line => scene.remove(line));
            pathLines = [];
        }

        // パスライン作成
        function createPathLine(points, color) {
            if (points.length < 2) return;
            
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            
            points.forEach(point => {
                positions.push(point.x, 1.8, point.z);
            });
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const material = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.9,
                linewidth: 3
            });
            const line = new THREE.Line(geometry, material);
            
            scene.add(line);
            pathLines.push(line);
        }

        // 曲線経路計算
        function calculateCurvePath(startX, startZ, goalX, goalZ) {
            const numWaypoints = 5; // 中間点の数
            const path = [{x: startX, z: startZ}];
            
            // 直線経路上の中間点を生成
            for (let i = 1; i < numWaypoints; i++) {
                const t = i / numWaypoints;
                const x = startX + (goalX - startX) * t;
                const z = startZ + (goalZ - startZ) * t;
                path.push({x, z});
            }
            
            path.push({x: goalX, z: goalZ});
            
            // 各中間点をゾンビ回避のために調整
            for (let i = 1; i < path.length - 1; i++) {
                const point = path[i];
                let bestOffset = {x: 0, z: 0};
                let minDanger = Infinity;
                
                // 複数の回避候補点を試す
                const candidates = [
                    {x: 0, z: 0}, // 元の位置
                    {x: 3, z: 0}, {x: -3, z: 0}, {x: 0, z: 3}, {x: 0, z: -3},
                    {x: 2, z: 2}, {x: -2, z: 2}, {x: 2, z: -2}, {x: -2, z: -2},
                    {x: 4, z: 0}, {x: -4, z: 0}, {x: 0, z: 4}, {x: 0, z: -4}
                ];
                
                candidates.forEach(offset => {
                    const testX = point.x + offset.x;
                    const testZ = point.z + offset.z;
                    
                    // 境界チェック
                    if (Math.abs(testX) > FIELD_SIZE/2 - 2 || Math.abs(testZ) > FIELD_SIZE/2 - 2) {
                        return;
                    }
                    
                    // ゾンビとの危険度計算
                    let dangerScore = 0;
                    zombies.forEach(zombie => {
                        if (zombie.state === 'down') return;
                        
                        const dx = zombie.x - testX;
                        const dz = zombie.z - testZ;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        if (distance < 8) {
                            dangerScore += (8 - distance) / distance;
                        }
                    });
                    
                    // ゴールからの距離ペナルティ
                    const goalDistance = Math.sqrt((goalX - testX) ** 2 + (goalZ - testZ) ** 2);
                    dangerScore += goalDistance * 0.1;
                    
                    if (dangerScore < minDanger) {
                        minDanger = dangerScore;
                        bestOffset = offset;
                    }
                });
                
                point.x += bestOffset.x;
                point.z += bestOffset.z;
            }
            
            return path;
        }

        // ゲームの初期化
        function initGame() {
            console.log('ゲーム初期化開始 - ステージ', currentStage);
            
            // 既存の入口・出口オブジェクトをクリア
            const toRemove = [];
            scene.children.forEach(child => {
                if (child.userData && child.userData.removable) {
                    toRemove.push(child);
                }
            });
            toRemove.forEach(obj => scene.remove(obj));
            
            // エンティティのクリア
            humans.forEach(human => {
                if (human.mesh) scene.remove(human.mesh);
            });
            zombies.forEach(zombie => {
                if (zombie.mesh) scene.remove(zombie.mesh);
            });
            effects.forEach(effect => {
                if (effect.mesh) scene.remove(effect.mesh);
            });
            clearDebugLines();
            
            humans = [];
            zombies = [];
            effects = [];

            // 新しい部屋を生成
            generateEntrancesAndExits();

            // 人の配置（入口エリアからスタート）
            console.log('人を作成中...');
            if (entrances.length > 0) {
                const entrance = entrances[0];
                humans.push(createHuman(entrance.x, entrance.z));
            }

            // ゾンビの配置（10匹固定）
            console.log('ゾンビを作成中...');
            const zombieCount = 10;
            for (let i = 0; i < zombieCount; i++) {
                const x = (Math.random() - 0.5) * (FIELD_SIZE - 4);
                const z = (Math.random() - 0.5) * (FIELD_SIZE - 4);
                zombies.push(createZombie(x, z));
            }

            gameTime = 0;
            updateHUD();
            updateDebugInfo();
            console.log('ゲーム初期化完了:', humans.length, 'humans,', zombies.length, 'zombies');
        }

        // HUDの更新
        function updateHUD() {
            const aliveHumans = humans.filter(h => h.alive).length;
            document.getElementById('humanCount').textContent = `人: ${aliveHumans}`;
            document.getElementById('timer').textContent = `時間: ${Math.floor(gameTime)}s`;
        }

        // ゲーム開始
        function startGame() {
            console.log('ゲーム開始関数呼び出し');
            gameState = 'playing';
            gameRunning = true;
            document.getElementById('gameStatus').style.display = 'none';
            initGame();
            console.log('ゲーム開始完了! 人数:', humans.length, 'ゾンビ数:', zombies.length);
            updateDebugInfo();
        }

        // タッチ/クリック処理
        function handleTouch(event) {
            if (gameState !== 'playing') return;

            event.preventDefault();
            const touches = event.touches || [event];

            for (let i = 0; i < touches.length; i++) {
                const touch = touches[i];
                const rect = renderer.domElement.getBoundingClientRect();
                const x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                const y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

                // レイキャスティングで3D座標を取得
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
                
                const intersect = raycaster.intersectObjects(scene.children.filter(obj => obj.name === 'ground'));
                let point;
                
                if (intersect.length > 0) {
                    point = intersect[0].point;
                } else {
                    // 床との交点を計算
                    const ray = raycaster.ray;
                    const t = -ray.origin.y / ray.direction.y;
                    point = ray.origin.clone().add(ray.direction.clone().multiplyScalar(t));
                }
                
                console.log('タップ位置:', point.x.toFixed(2), point.z.toFixed(2));
                createRippleEffect(point.x, point.z);
                affectZombiesInRadius(point.x, point.z, TAP_RADIUS);
            }
        }

        // 範囲内のゾンビに影響を与える
        function affectZombiesInRadius(x, z, radius) {
            zombies.forEach(zombie => {
                const dx = zombie.x - x;
                const dz = zombie.z - z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance <= radius && (zombie.state === 'wandering' || zombie.state === 'rotating' || zombie.state === 'chasing')) {
                    zombie.state = 'down';
                    zombie.downTimer = ZOMBIE_DOWN_TIME;
                    // ランダムな方向を設定（転んだ表現）
                    zombie.direction = Math.random() * Math.PI * 2;
                    zombie.wanderTimer = 0;
                    
                    // ダウン状態の視覚化
                    zombie.mesh.rotation.z = Math.PI / 4; // 45度傾ける
                }
            });
        }

        // デバッグ情報の更新
        function updateDebugInfo() {
            const debugElement = document.getElementById('debugText');
            if (!debugElement) {
                console.log('デバッグ要素が見つかりません');
                return;
            }
            
            let debugText = `ステージ: ${currentStage}<br>`;
            debugText += `ゲーム状態: ${gameState}<br>`;
            debugText += `実行中: ${gameRunning}<br>`;
            debugText += `時間: ${gameTime.toFixed(1)}s<br>`;
            debugText += `人数: ${humans.length}, ゾンビ数: ${zombies.length}<br>`;
            debugText += `出口数: ${exits.length}<br>`;
            
            if (humans.length > 0) {
                const human = humans[0];
                debugText += `人: (${human.x.toFixed(1)}, ${human.z.toFixed(1)}) 生存: ${human.alive}<br>`;
                debugText += `接触タイマー: ${human.contactTimer.toFixed(2)}s<br>`;
            } else {
                debugText += `人: 未作成<br>`;
            }
            
            if (zombies.length > 0) {
                zombies.forEach((zombie, i) => {
                    debugText += `ゾンビ${i+1}: (${zombie.x.toFixed(1)}, ${zombie.z.toFixed(1)}) ${zombie.state}`;
                    if (zombie.state === 'wandering') {
                        debugText += ` 徘徊中`;
                    } else if (zombie.state === 'rotating') {
                        debugText += ` 回転中`;
                    } else if (zombie.state === 'chasing') {
                        debugText += ` 追跡中`;
                    } else if (zombie.state === 'down') {
                        debugText += ` 転倒中`;
                    }
                    debugText += `<br>`;
                });
            } else {
                debugText += `ゾンビ: 未作成<br>`;
            }
            
            debugElement.innerHTML = debugText;
        }

        // ゲームロジックの更新
        function updateGame(deltaTime) {
            if (!gameRunning) return;

            gameTime += deltaTime;
            
            console.log('ゲーム更新中:', gameTime.toFixed(1), 'deltaTime:', deltaTime.toFixed(3));

            // 人の更新
            humans.forEach(human => {
                if (!human.alive) return;

                // 最も近い出口を確認（動的に変更）
                const nearestExit = findNearestExit(human.x, human.z);
                if (nearestExit !== human.currentTarget) {
                    human.currentTarget = nearestExit;
                    human.targetX = nearestExit.x;
                    human.targetZ = nearestExit.z;
                    console.log('目標変更:', nearestExit);
                }

                // 出口への基本方向
                const goalDx = human.targetX - human.x;
                const goalDz = human.targetZ - human.z;
                const goalDistance = Math.sqrt(goalDx * goalDx + goalDz * goalDz);

                if (goalDistance <= 2.0) {
                    // 出口到達 - 次のステージへ
                    nextStage();
                    return;
                }

                // 経路を定期的に更新（1秒ごと）
                human.pathUpdateTimer += deltaTime;
                if (human.pathUpdateTimer >= 1.0 || human.currentPath.length === 0) {
                    human.currentPath = calculateCurvePath(human.x, human.z, human.targetX, human.targetZ);
                    human.pathIndex = 0;
                    human.pathUpdateTimer = 0;
                    
                    // パス表示をクリアして再描画
                    clearPathLines();
                    
                    // 詳細ログ出力
                    logPathInfo(human.currentPath);
                    
                    // 曲線経路表示（明るい緑）
                    createPathLine(human.currentPath, 0x00ff00);
                    
                    // ウェイポイントマーカー表示
                    createWaypointMarkers(human.currentPath);
                    
                    // ゾンビ危険度表示
                    createDangerZones();
                    
                    console.log('=== 経路更新完了 ===');
                }

                // 経路に沿って移動
                if (human.currentPath.length > 1 && human.pathIndex < human.currentPath.length - 1) {
                    const currentWaypoint = human.currentPath[human.pathIndex];
                    const nextWaypoint = human.currentPath[human.pathIndex + 1];
                    
                    const dx = nextWaypoint.x - human.x;
                    const dz = nextWaypoint.z - human.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    // 次のウェイポイントに近づいたら次へ
                    if (distance < 1.0) {
                        human.pathIndex++;
                        console.log(`ウェイポイント${human.pathIndex}に到達`);
                    } else {
                        // ウェイポイントに向かって移動
                        const moveX = (dx / distance) * human.speed * deltaTime;
                        const moveZ = (dz / distance) * human.speed * deltaTime;
                        
                        human.x += moveX;
                        human.z += moveZ;
                        human.mesh.position.set(human.x, 1.0, human.z);
                        
                        // 進行方向を記録
                        human.direction = Math.atan2(dz, dx);
                    }
                }

                // ゾンビとの即死判定
                zombies.forEach(zombie => {
                    if (zombie.state === 'down') return;
                    
                    const zombieDx = zombie.x - human.x;
                    const zombieDz = zombie.z - human.z;
                    const zombieDistance = Math.sqrt(zombieDx * zombieDx + zombieDz * zombieDz);
                    
                    if (zombieDistance <= CONTACT_DISTANCE) {
                        human.alive = false;
                        console.log('人が死亡しました（移動中にゾンビと接触）');
                        checkLoseCondition();
                        return;
                    }
                });
            });

            // ゾンビの更新
            zombies.forEach(zombie => {
                if (zombie.state === 'down') {
                    zombie.downTimer -= deltaTime;
                    if (zombie.downTimer <= 0) {
                        zombie.state = 'wandering';
                        zombie.mesh.rotation.z = 0; // 元の向きに戻す
                        zombie.wanderTimer = 0;
                    }
                    return;
                }

                // 最も近い人を探す
                let nearestHuman = null;
                let nearestDistance = Infinity;
                
                humans.forEach(human => {
                    if (!human.alive) return;
                    const dx = human.x - zombie.x;
                    const dz = human.z - zombie.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestHuman = human;
                    }
                });

                if (nearestHuman) {
                    const dx = nearestHuman.x - zombie.x;
                    const dz = nearestHuman.z - zombie.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    // 接触判定（即死）
                    if (distance <= CONTACT_DISTANCE) {
                        nearestHuman.alive = false;
                        console.log('人が死亡しました（ゾンビと接触）');
                        checkLoseCondition();
                        return;
                    }

                    // 状態に応じた行動
                    if (zombie.state === 'wandering') {
                        // ランダム移動
                        zombie.wanderTimer += deltaTime;
                        if (zombie.wanderTimer >= 2.0) {
                            zombie.direction = Math.random() * Math.PI * 2;
                            zombie.wanderTimer = 0;
                        }
                        
                        // 移動
                        const moveX = Math.cos(zombie.direction) * zombie.speed * 0.5 * deltaTime;
                        const moveZ = Math.sin(zombie.direction) * zombie.speed * 0.5 * deltaTime;
                        zombie.x += moveX;
                        zombie.z += moveZ;
                        zombie.mesh.position.set(zombie.x, 1.0, zombie.z);
                        
                        // 人が検知範囲内にいるか確認
                        if (distance <= ZOMBIE_DETECTION_RANGE) {
                            zombie.state = 'rotating';
                            zombie.targetDirection = Math.atan2(dz, dx);
                            
                            // 最短回転方向を決定
                            const angleDiff = zombie.targetDirection - zombie.direction;
                            const normalizedDiff = ((angleDiff + Math.PI) % (2 * Math.PI)) - Math.PI;
                            zombie.rotationDirection = normalizedDiff > 0 ? 1 : -1;
                        }
                    } else if (zombie.state === 'rotating') {
                        // 目標方向に回転
                        zombie.direction += zombie.rotationDirection * ZOMBIE_ROTATION_SPEED * deltaTime;
                        
                        // 目標方向に到達したか確認
                        const angleDiff = zombie.targetDirection - zombie.direction;
                        const normalizedDiff = ((angleDiff + Math.PI) % (2 * Math.PI)) - Math.PI;
                        
                        if (Math.abs(normalizedDiff) < 0.1) {
                            zombie.state = 'chasing';
                            zombie.direction = zombie.targetDirection;
                        }
                    } else if (zombie.state === 'chasing') {
                        // 人の現在位置に向かって最短距離で移動
                        const currentDirection = Math.atan2(dz, dx);
                        zombie.direction = currentDirection;
                        
                        if (distance > 0.3) {
                            const moveX = Math.cos(zombie.direction) * zombie.speed * deltaTime;
                            const moveZ = Math.sin(zombie.direction) * zombie.speed * deltaTime;
                            
                            zombie.x += moveX;
                            zombie.z += moveZ;
                            zombie.mesh.position.set(zombie.x, 1.0, zombie.z);
                        }
                        
                        // 人が遠くに行ったらランダム移動に戻る
                        if (distance > ZOMBIE_DETECTION_RANGE) {
                            zombie.state = 'wandering';
                            zombie.wanderTimer = 0;
                        }
                    }
                } else {
                    // 人がいない場合はランダム移動
                    zombie.state = 'wandering';
                    zombie.wanderTimer += deltaTime;
                    if (zombie.wanderTimer >= 2.0) {
                        zombie.direction = Math.random() * Math.PI * 2;
                        zombie.wanderTimer = 0;
                    }
                    
                    // 移動
                    const moveX = Math.cos(zombie.direction) * zombie.speed * 0.5 * deltaTime;
                    const moveZ = Math.sin(zombie.direction) * zombie.speed * 0.5 * deltaTime;
                    zombie.x += moveX;
                    zombie.z += moveZ;
                    zombie.mesh.position.set(zombie.x, 1.0, zombie.z);
                }
            });

            // エフェクトの更新
            effects = effects.filter(effect => {
                effect.life -= deltaTime;
                const alpha = effect.life / effect.maxLife;
                effect.mesh.material.opacity = alpha * 0.6;
                
                if (effect.life <= 0) {
                    scene.remove(effect.mesh);
                    return false;
                }
                return true;
            });

            // デバッグライン表示
            clearDebugLines();
            
            // 人の進行方向ライン
            humans.forEach(human => {
                if (!human.alive) return;
                const lineLength = 3;
                const endX = human.x + Math.cos(human.direction) * lineLength;
                const endZ = human.z + Math.sin(human.direction) * lineLength;
                createDebugLine(human.x, human.z, endX, endZ, 0x00aaff);
                
                // 現在のウェイポイントへのライン
                if (human.currentPath.length > 0 && human.pathIndex < human.currentPath.length) {
                    const targetWaypoint = human.currentPath[human.pathIndex];
                    createDebugLine(human.x, human.z, targetWaypoint.x, targetWaypoint.z, 0x00ff00);
                }
            });
            
            // ゾンビの進行方向ライン
            zombies.forEach(zombie => {
                if (zombie.state === 'down') return;
                const lineLength = 3;
                const endX = zombie.x + Math.cos(zombie.direction) * lineLength;
                const endZ = zombie.z + Math.sin(zombie.direction) * lineLength;
                
                let color = 0xff0000; // 基本色（赤）
                if (zombie.state === 'wandering') color = 0xff4444; // 徘徊中（薄い赤）
                if (zombie.state === 'rotating') color = 0xffaa00; // 回転中（オレンジ）
                if (zombie.state === 'chasing') color = 0xff0088; // 追跡中（ピンク）
                
                createDebugLine(zombie.x, zombie.z, endX, endZ, color);
            });

            updateHUD();
            updateDebugInfo();
        }

        // 次のステージへ
        function nextStage() {
            // 到達した出口の情報を記録
            const human = humans[0];
            const reachedExit = findNearestExit(human.x, human.z);
            if (reachedExit) {
                // 壁上での位置を計算
                let position;
                if (reachedExit.wall === 'north' || reachedExit.wall === 'south') {
                    position = reachedExit.x;
                } else {
                    position = reachedExit.z;
                }
                
                lastExitInfo = {
                    wall: reachedExit.wall,
                    position: position
                };
                console.log('出口情報記録:', lastExitInfo);
            }
            
            currentStage++;
            console.log('ステージ', currentStage, 'へ移行');
            
            gameState = 'win';
            gameRunning = false;
            document.getElementById('statusText').textContent = `ステージ${currentStage-1}クリア！`;
            document.getElementById('startButton').textContent = `ステージ${currentStage}へ`;
            document.getElementById('gameStatus').style.display = 'block';
        }

        // 勝利条件チェック（廃止）
        function checkWinCondition() {
            // nextStage()に置き換え
        }

        // 敗北条件チェック
        function checkLoseCondition() {
            const aliveHumans = humans.filter(h => h.alive);
            if (aliveHumans.length === 0) {
                gameLose();
            }
        }

        // ゲーム勝利
        function gameWin() {
            gameState = 'win';
            gameRunning = false;
            document.getElementById('statusText').textContent = 'ステージクリア！';
            document.getElementById('startButton').textContent = '次のステージ';
            document.getElementById('gameStatus').style.display = 'block';
        }

        // ゲーム敗北
        function gameLose() {
            gameState = 'lose';
            gameRunning = false;
            document.getElementById('statusText').textContent = 'ゲームオーバー';
            document.getElementById('startButton').textContent = 'リトライ';
            document.getElementById('gameStatus').style.display = 'block';
        }

        // ウィンドウリサイズ処理
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // アニメーションループ
        let lastTime = 0;
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            updateGame(deltaTime);
            
            // ゲーム開始前でもデバッグ情報を更新
            if (gameState === 'menu') {
                updateDebugInfo();
            }
            
            renderer.render(scene, camera);
        }

        // 初期化
        function init() {
            console.log('初期化開始');
            initCamera();
            initScene();
            initRenderer();

            // 初期デバッグ情報の表示
            updateDebugInfo();

            // イベントリスナーの追加
            window.addEventListener('resize', onWindowResize);
            
            // タッチイベント
            renderer.domElement.addEventListener('touchstart', handleTouch, { passive: false });
            renderer.domElement.addEventListener('touchmove', handleTouch, { passive: false });
            
            // マウスイベント（PC用）
            renderer.domElement.addEventListener('mousedown', handleTouch);

            // スタートボタンのイベントリスナー
            const startButton = document.getElementById('startButton');
            if (startButton) {
                startButton.addEventListener('click', startGame);
                console.log('スタートボタンイベント設定完了');
            } else {
                console.error('スタートボタンが見つかりません');
            }

            console.log('初期化完了、アニメーション開始');
            animate(0);
            
            // 自動でゲーム開始
            setTimeout(() => {
                console.log('自動ゲーム開始');
                startGame();
            }, 1000);
        }

        // ページ読み込み完了後に初期化
        window.addEventListener('load', init);
    </script>
</body>
</html>