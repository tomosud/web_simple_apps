<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Underfloor Guardians</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* 画面の高さを最小に100vh */
            overflow: hidden; /* スクロールバー非表示 */
        }
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none; /* タッチイベントをゲームに透過させる */
        }
        #gameStatus {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            display: none;
        }
        #startButton {
            margin-top: 15px;
            padding: 10px 20px;
            font-size: 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #debugInfo {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 12px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
            z-index: 150;
            pointer-events: none; /* タッチイベントをゲームに透過させる */
            display: none; /* 初期は非表示 */
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="hud">
            <div id="stageCount">ステージ: 1</div>
            <div id="timer">時間: 0s</div>
        </div>
        <div id="gameStatus" style="display: none;">
            <div id="statusText">ゲーム開始</div>
            <button id="startButton">スタート</button>
        </div>
        <div id="debugInfo">
            <div>デバッグ情報:</div>
            <div id="debugText">初期化中...</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ゲーム状態
        let scene, camera, renderer;
        let gameState = 'menu'; // 'menu', 'playing', 'win', 'lose'
        let gameTime = 0;
        let gameRunning = false;

        // ゲームエンティティ
        let entities = []; // 統一エンティティシステム
        let effects = [];
        let debugLines = []; // デバッグライン用
        let currentStage = 1;
        let entrances = [];
        let exits = [];
        let lastExitInfo = null; // 前のステージの出口情報
        let pathLines = []; // パス表示用
        
        // 後方互換性のためのアクセサー
        let humans = [];
        let zombies = [];

        // ゲーム設定（9:16比率統一）
        const FIELD_SIZE_X = 36; // 9:16比率の横幅
        const FIELD_SIZE_Z = 64; // 9:16比率の縦幅
        const HUMAN_SPEED = 1.5;
        const ZOMBIE_SPEED = 1.0;
        const ZOMBIE_DOWN_TIME = 2.0;
        const TAP_RADIUS = 4.0;
        const CONTACT_TIME_LIMIT = 1.0; // 接触判定時間（秒）
        const CONTACT_DISTANCE = 1.0; // 接触判定距離
        const ZOMBIE_DETECTION_RANGE = 20.0; // ゾンビの人検知範囲（遠くから見渡す）
        const HUMAN_AVOIDANCE_RANGE = 8.0; // 人の回避範囲（適正化）
        const ZOMBIE_ROTATION_SPEED = 4.0; // ゾンビの回転速度
        const ENTRANCE_SIZE = 3.0; // 入口のサイズ
        const EXIT_SIZE = 3.0; // 出口のサイズ

        // 床下カメラの初期化
        function initCamera() {
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // 床下から見上げる視点（Y軸を反転）
            camera.position.set(0, -50, 0); // カメラをさらに遠くに移動して壁全体を見えるように
            camera.lookAt(0, 0, 0);
            camera.up.set(0, 0, 1); // Z軸を上方向に設定
            console.log('カメラ初期化完了:', camera.position);
        }

        // シーンの初期化
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            // 環境光の追加
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            // 方向光の追加
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(-1, 1, 1);
            scene.add(directionalLight);

            // 床グリッドの作成（16:9比率）
            const gridHelper = new THREE.GridHelper(FIELD_SIZE_X, FIELD_SIZE_X, 0x444444, 0x222222);
            gridHelper.material.transparent = true;
            gridHelper.material.opacity = 0.6;
            gridHelper.name = 'ground'; // 床に名前を付ける
            gridHelper.scale.set(1, 1, FIELD_SIZE_Z / FIELD_SIZE_X); // Z軸をスケール調整
            scene.add(gridHelper);

            // 実際の床面（クリック判定用）
            const floorGeometry = new THREE.PlaneGeometry(FIELD_SIZE_X, FIELD_SIZE_Z);
            const floorMaterial = new THREE.MeshBasicMaterial({
                transparent: true,
                opacity: 0.01,
                color: 0x000000
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.name = 'ground';
            scene.add(floor);

            // 境界壁の作成
            const wallMaterial = new THREE.MeshBasicMaterial({
                color: 0xaaaaaa,
                transparent: true,
                opacity: 0.8
            });
            
            // 4つの壁を作成
            const wallHeight = 2;
            const wallThickness = 0.5;
            
            const walls = [
                { pos: [0, wallHeight/2, FIELD_SIZE_Z/2], size: [FIELD_SIZE_X, wallHeight, wallThickness] },
                { pos: [0, wallHeight/2, -FIELD_SIZE_Z/2], size: [FIELD_SIZE_X, wallHeight, wallThickness] },
                { pos: [FIELD_SIZE_X/2, wallHeight/2, 0], size: [wallThickness, wallHeight, FIELD_SIZE_Z] },
                { pos: [-FIELD_SIZE_X/2, wallHeight/2, 0], size: [wallThickness, wallHeight, FIELD_SIZE_Z] }
            ];

            walls.forEach(wall => {
                const geometry = new THREE.BoxGeometry(...wall.size);
                const mesh = new THREE.Mesh(geometry, wallMaterial);
                mesh.position.set(...wall.pos);
                scene.add(mesh);
            });

            // 入口と出口を生成
            generateEntrancesAndExits();
        }

        // レンダラーの初期化
        function initRenderer() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);
        }

        // 対向する壁を取得
        function getOppositeWall(wall) {
            const opposites = {
                'north': 'south',
                'south': 'north',
                'east': 'west',
                'west': 'east'
            };
            return opposites[wall];
        }

        // 入口と出口の生成
        function generateEntrancesAndExits() {
            console.log('新しい部屋を生成中... ステージ', currentStage);
            entrances = [];
            exits = [];
            
            // 全ての壁
            const allWalls = ['north', 'south', 'east', 'west'];
            
            let entrance;
            let entranceWall;
            
            if (lastExitInfo && currentStage > 1) {
                // 前のステージの出口情報から隣の部屋の入口を計算
                entranceWall = getOppositeWall(lastExitInfo.wall);
                entrance = createDoorOnWall(entranceWall, lastExitInfo.position);
                console.log('前の出口から入口生成:', lastExitInfo.wall, '→', entranceWall, 'at', lastExitInfo.position);
            } else {
                // 初回はランダム
                entranceWall = allWalls[Math.floor(Math.random() * allWalls.length)];
                entrance = createDoorOnWall(entranceWall);
                console.log('ランダム入口生成:', entranceWall);
            }
            entrance.type = 'entrance';
            entrances.push(entrance);
            
            // 入口エリアの視覚化（床面）
            const entranceGeometry = new THREE.CircleGeometry(ENTRANCE_SIZE, 16);
            const entranceMaterial = new THREE.MeshBasicMaterial({
                color: 0x0099ff,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const entranceMesh = new THREE.Mesh(entranceGeometry, entranceMaterial);
            entranceMesh.position.set(entrance.x, 0.2, entrance.z);
            entranceMesh.rotation.x = -Math.PI / 2;
            entranceMesh.userData.removable = true;
            scene.add(entranceMesh);
            console.log('入口エリア作成:', entrance.x, entrance.z);
            
            // 出口を生成（入口以外の壁からランダム選択、最大2個）
            const availableWalls = allWalls.filter(wall => wall !== entranceWall);
            const numExits = Math.floor(Math.random() * 2) + 1; // 1つまたは2つの出口
            console.log('出口数:', numExits, '利用可能な壁:', availableWalls);
            
            const minDistance = 15; // 入口と出口の最小距離
            let attempts = 0;
            const maxAttempts = 20;
            
            for (let i = 0; i < numExits && availableWalls.length > 0 && attempts < maxAttempts; i++) {
                const wallIndex = Math.floor(Math.random() * availableWalls.length);
                const selectedWall = availableWalls[wallIndex];
                console.log('出口', i+1, '壁選択:', selectedWall);
                
                const exit = createDoorOnWall(selectedWall);
                exit.type = 'exit';
                
                // 入口との距離をチェック
                const distanceToEntrance = Math.sqrt(
                    (exit.x - entrance.x) * (exit.x - entrance.x) +
                    (exit.z - entrance.z) * (exit.z - entrance.z)
                );
                
                if (distanceToEntrance >= minDistance) {
                    exits.push(exit);
                    availableWalls.splice(wallIndex, 1); // 使用済み壁を削除
                    
                    // 出口エリアの視覚化（床面）
                    const exitGeometry = new THREE.CircleGeometry(EXIT_SIZE, 16);
                    const exitMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00ff00,
                        transparent: true,
                        opacity: 0.8,
                        side: THREE.DoubleSide
                    });
                    const exitMesh = new THREE.Mesh(exitGeometry, exitMaterial);
                    exitMesh.position.set(exit.x, 0.2, exit.z);
                    exitMesh.rotation.x = -Math.PI / 2;
                    exitMesh.userData.removable = true;
                    scene.add(exitMesh);
                    console.log('出口エリア作成:', exit.x, exit.z, '距離:', distanceToEntrance.toFixed(1));
                } else {
                    console.log('出口却下（距離不足）:', distanceToEntrance.toFixed(1), '<', minDistance);
                    i--; // やり直し
                }
                attempts++;
            }
            
            console.log('入口:', entrances);
            console.log('出口:', exits);
        }

        // 指定された壁にドアを作成
        function createDoorOnWall(wall, position = null) {
            let door;
            const margin = 4; // 壁の端からの余白
            
            switch (wall) {
                case 'north':
                    const posX = position !== null ? position : (Math.random() - 0.5) * (FIELD_SIZE_X - margin * 2);
                    door = {
                        x: posX,
                        z: FIELD_SIZE_Z/2 - 2,
                        wall: 'north'
                    };
                    break;
                case 'south':
                    const posX2 = position !== null ? position : (Math.random() - 0.5) * (FIELD_SIZE_X - margin * 2);
                    door = {
                        x: posX2,
                        z: -FIELD_SIZE_Z/2 + 2,
                        wall: 'south'
                    };
                    break;
                case 'east':
                    const posZ = position !== null ? position : (Math.random() - 0.5) * (FIELD_SIZE_Z - margin * 2);
                    door = {
                        x: FIELD_SIZE_X/2 - 2,
                        z: posZ,
                        wall: 'east'
                    };
                    break;
                case 'west':
                    const posZ2 = position !== null ? position : (Math.random() - 0.5) * (FIELD_SIZE_Z - margin * 2);
                    door = {
                        x: -FIELD_SIZE_X/2 + 2,
                        z: posZ2,
                        wall: 'west'
                    };
                    break;
            }
            console.log('ドア作成:', wall, 'at', door.x.toFixed(1), door.z.toFixed(1));
            return door;
        }

        // 最も近い出口を見つける
        function findNearestExit(x, z) {
            let nearestExit = null;
            let nearestDistance = Infinity;
            
            exits.forEach(exit => {
                const dx = exit.x - x;
                const dz = exit.z - z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance < nearestDistance) {
                    nearestDistance = distance;
                    nearestExit = exit;
                }
            });
            
            return nearestExit;
        }

        // エンティティID生成
        let nextEntityId = 1;
        function generateEntityId() {
            return nextEntityId++;
        }

        // エンティティ統一システム
        function createEntity(type, x, z, options = {}) {
            const entity = {
                id: generateEntityId(),
                type: type, // 'human' or 'zombie'
                state: type === 'human' ? 'human' : 'wandering',
                mesh: createEntityMesh(type === 'human' ? 0x0066ff : 0xff0000),
                position: { x: x, z: z },
                movement: {
                    speed: type === 'human' ? HUMAN_SPEED : ZOMBIE_SPEED,
                    direction: options.direction || (type === 'zombie' ? Math.random() * Math.PI * 2 : 0),
                    path: [],
                    pathIndex: 0
                },
                ai: {
                    target: null,
                    detectionRange: type === 'zombie' ? ZOMBIE_DETECTION_RANGE : 0,
                    behavior: type === 'human' ? 'seek' : 'wander'
                },
                timers: {
                    stateTimer: 0,
                    pathUpdateTimer: 0,
                    contactTimer: 0,
                    wanderTimer: 0,
                    downTimer: 0
                },
                // 後方互換性のためのプロパティ
                alive: type === 'human',
                ...options
            };

            // 人の場合の追加設定
            if (type === 'human') {
                const nearestExit = findNearestExit(x, z);
                entity.targetX = nearestExit ? nearestExit.x : 0;
                entity.targetZ = nearestExit ? nearestExit.z : 0;
                entity.currentTarget = nearestExit;
            }

            // ゾンビの場合の追加設定
            if (type === 'zombie') {
                entity.targetDirection = 0;
                entity.rotationDirection = 1;
            }

            entity.mesh.position.set(x, 1.0, z);
            scene.add(entity.mesh);
            entities.push(entity);

            console.log(`${type}エンティティ作成:`, entity.id, 'at', x, z);
            return entity;
        }

        // エンティティ検索ヘルパー
        function getEntitiesByType(type) {
            return entities.filter(entity => entity.type === type);
        }

        function getHumans() {
            return getEntitiesByType('human');
        }

        function getZombies() {
            return getEntitiesByType('zombie');
        }

        // 後方互換性の更新
        function updateCompatibilityArrays() {
            humans = getHumans();
            zombies = getZombies();
        }

        // 球体メッシュの作成
        function createEntityMesh(color) {
            const geometry = new THREE.SphereGeometry(0.6, 16, 12);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.y = 1.0;
            
            console.log('エンティティメッシュ作成:', color.toString(16));
            return mesh;
        }

        // 人の作成（後方互換性）
        function createHuman(x, z) {
            const entity = createEntity('human', x, z);
            // 後方互換性のためのプロパティマッピング
            entity.x = entity.position.x;
            entity.z = entity.position.z;
            entity.speed = entity.movement.speed;
            entity.direction = entity.movement.direction;
            entity.currentPath = entity.movement.path;
            entity.pathIndex = entity.movement.pathIndex;
            entity.contactTimer = entity.timers.contactTimer;
            entity.pathUpdateTimer = entity.timers.pathUpdateTimer;
            
            console.log('人を作成:', x, z, '→ 出口:', entity.targetX, entity.targetZ);
            return entity;
        }

        // ゾンビの作成（後方互換性）
        function createZombie(x, z) {
            const entity = createEntity('zombie', x, z);
            // 後方互換性のためのプロパティマッピング
            entity.x = entity.position.x;
            entity.z = entity.position.z;
            entity.speed = entity.movement.speed;
            entity.direction = entity.movement.direction;
            entity.downTimer = entity.timers.downTimer;
            entity.target = entity.ai.target;
            entity.contactTimer = entity.timers.contactTimer;
            entity.wanderTimer = entity.timers.wanderTimer;
            
            console.log('ゾンビを作成:', x, z);
            return entity;
        }

        // エフェクトの作成（タップ時の波紋）
        function createRippleEffect(x, z) {
            const effect = {
                mesh: null,
                x: x,
                z: z,
                radius: 0,
                maxRadius: TAP_RADIUS,
                life: 1.0,
                maxLife: 1.0
            };

            // 半透明の円から黄色い輪に変更
            const geometry = new THREE.RingGeometry(0.1, TAP_RADIUS, 32);
            const material = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            effect.mesh = new THREE.Mesh(geometry, material);
            effect.mesh.position.set(x, 0.1, z);
            effect.mesh.rotation.x = -Math.PI / 2;
            scene.add(effect.mesh);

            effects.push(effect);
        }

        // デバッグライン作成
        function createDebugLine(startX, startZ, endX, endZ, color) {
            const points = [];
            points.push(new THREE.Vector3(startX, 1.5, startZ));
            points.push(new THREE.Vector3(endX, 1.5, endZ));
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.8 });
            const line = new THREE.Line(geometry, material);
            
            scene.add(line);
            debugLines.push(line);
        }

        // デバッグラインをクリア
        function clearDebugLines() {
            debugLines.forEach(line => scene.remove(line));
            debugLines = [];
        }

        // パスラインをクリア
        function clearPathLines() {
            pathLines.forEach(line => scene.remove(line));
            pathLines = [];
        }

        // パスライン作成
        function createPathLine(points, color) {
            if (points.length < 2) return;
            
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            
            points.forEach(point => {
                positions.push(point.x, 1.8, point.z);
            });
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const material = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.9,
                linewidth: 3
            });
            const line = new THREE.Line(geometry, material);
            
            scene.add(line);
            pathLines.push(line);
        }

        // ゾンビ危険ゾーンの表示
        function createDangerZones() {
            // 既存の危険ゾーンをクリア
            const toRemove = [];
            scene.children.forEach(child => {
                if (child.userData && child.userData.dangerZone) {
                    toRemove.push(child);
                }
            });
            toRemove.forEach(obj => scene.remove(obj));

            // 後方互換性のため配列を更新
            updateCompatibilityArrays();

            // 各ゾンビの危険ゾーンを表示
            zombies.forEach(zombie => {
                if (zombie.state === 'down') return;

                // 危険ゾーンの細い円のみ表示
                const visualRadius = (HUMAN_AVOIDANCE_RANGE / 3) * 0.6; // 60%に縮小
                const outerRadius = visualRadius;
                const innerRadius = visualRadius - 0.1; // 非常に細いリング
                
                // 細い円のみ（塗りつぶしなし）
                const geometry = new THREE.RingGeometry(innerRadius, outerRadius, 32);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                const dangerRing = new THREE.Mesh(geometry, material);
                dangerRing.position.set(zombie.x, 0.1, zombie.z);
                dangerRing.rotation.x = -Math.PI / 2;
                dangerRing.userData.dangerZone = true;
                scene.add(dangerRing);
            });
        }

        // スムーズパス計算（改善版）
        function calculateCurvePath(startX, startZ, goalX, goalZ) {
            // ゴールまでの距離で動的にウェイポイント数を決定
            const totalDistance = Math.sqrt((goalX - startX) ** 2 + (goalZ - startZ) ** 2);
            const numWaypoints = Math.max(3, Math.min(5, Math.floor(totalDistance / 8))); // 距離に応じて調整
            
            const path = [{x: startX, z: startZ}];
            
            // 直線経路上の中間点を生成
            for (let i = 1; i < numWaypoints; i++) {
                const t = i / numWaypoints;
                const x = startX + (goalX - startX) * t;
                const z = startZ + (goalZ - startZ) * t;
                path.push({x, z});
            }
            
            path.push({x: goalX, z: goalZ});
            
            // 各中間点をゾンビ回避のために調整
            for (let i = 1; i < path.length - 1; i++) {
                const point = path[i];
                let bestOffset = {x: 0, z: 0};
                let minDanger = Infinity;
                
                // 細かい回避用の候補点（約2倍に増加）
                const candidates = [
                    {x: 0, z: 0}, // 元の位置
                    
                    // 細かい調整用（1単位刻み）
                    {x: 1, z: 0}, {x: -1, z: 0}, {x: 0, z: 1}, {x: 0, z: -1},
                    {x: 1, z: 1}, {x: -1, z: 1}, {x: 1, z: -1}, {x: -1, z: -1},
                    
                    // 基本的な4方向（1.5単位）
                    {x: 1.5, z: 0}, {x: -1.5, z: 0}, {x: 0, z: 1.5}, {x: 0, z: -1.5},
                    {x: 1.5, z: 1.5}, {x: -1.5, z: 1.5}, {x: 1.5, z: -1.5}, {x: -1.5, z: -1.5},
                    
                    // 基本的な4方向（2単位）
                    {x: 2, z: 0}, {x: -2, z: 0}, {x: 0, z: 2}, {x: 0, z: -2},
                    {x: 2, z: 2}, {x: -2, z: 2}, {x: 2, z: -2}, {x: -2, z: -2},
                    
                    // 中距離回避（3単位）
                    {x: 3, z: 0}, {x: -3, z: 0}, {x: 0, z: 3}, {x: 0, z: -3},
                    {x: 3, z: 1.5}, {x: -3, z: 1.5}, {x: 1.5, z: 3}, {x: 1.5, z: -3},
                    {x: 3, z: -1.5}, {x: -3, z: -1.5}, {x: -1.5, z: 3}, {x: -1.5, z: -3},
                    
                    // 標準回避（4単位）
                    {x: 4, z: 0}, {x: -4, z: 0}, {x: 0, z: 4}, {x: 0, z: -4},
                    {x: 3, z: 3}, {x: -3, z: 3}, {x: 3, z: -3}, {x: -3, z: -3},
                    
                    // 大きな回避（5単位）
                    {x: 5, z: 0}, {x: -5, z: 0}, {x: 0, z: 5}, {x: 0, z: -5},
                    {x: 4, z: 3}, {x: -4, z: 3}, {x: 4, z: -3}, {x: -4, z: -3},
                    {x: 3, z: 4}, {x: -3, z: 4}, {x: 3, z: -4}, {x: -3, z: -4},
                    
                    // 緊急回避用（6単位）
                    {x: 6, z: 0}, {x: -6, z: 0}, {x: 0, z: 6}, {x: 0, z: -6}
                ];
                
                candidates.forEach(offset => {
                    const testX = point.x + offset.x;
                    const testZ = point.z + offset.z;
                    
                    // 境界チェック（16:9比率対応）
                    if (Math.abs(testX) > FIELD_SIZE_X/2 - 2 || Math.abs(testZ) > FIELD_SIZE_Z/2 - 2) {
                        return;
                    }
                    
                    // ゾンビとの危険度計算（バランス調整版）
                    let dangerScore = 0;
                    let tooClose = false;
                    let nearestZombieDistance = Infinity;
                    
                    zombies.forEach(zombie => {
                        if (zombie.state === 'down') return;
                        
                        const dx = zombie.x - testX;
                        const dz = zombie.z - testZ;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        nearestZombieDistance = Math.min(nearestZombieDistance, distance);
                        
                        // 絶対に近づかない距離（接触距離の2.5倍）
                        const criticalDistance = CONTACT_DISTANCE * 2.5;
                        if (distance < criticalDistance) {
                            tooClose = true;
                            dangerScore += 500; // 高いペナルティだが極端すぎない
                        }
                        // 回避したい距離（より滑らかなペナルティ）
                        else if (distance < HUMAN_AVOIDANCE_RANGE) {
                            const normalizedDistance = distance / HUMAN_AVOIDANCE_RANGE;
                            dangerScore += (1 - normalizedDistance) * 20; // 線形的なペナルティ
                        }
                    });
                    
                    // 危険すぎる場合は候補から除外
                    if (tooClose) {
                        return;
                    }
                    
                    // ゴールからの距離ペナルティ（動的調整）
                    const goalDistance = Math.sqrt((goalX - testX) ** 2 + (goalZ - testZ) ** 2);
                    
                    // ゴール近くでの特別処理
                    let goalPenalty = 0.1;
                    if (goalDistance < 8) {
                        // ゴール至近距離では大幅に直線優先
                        goalPenalty = 0.005;
                        
                        // ゴールに向かう直線上かチェック
                        const directPath = Math.sqrt((goalX - point.x) ** 2 + (goalZ - point.z) ** 2);
                        const currentToGoal = Math.sqrt((goalX - point.x) ** 2 + (goalZ - point.z) ** 2);
                        const testToGoal = Math.sqrt((goalX - testX) ** 2 + (goalZ - testZ) ** 2);
                        
                        // ゴールに近づく移動を大幅優遇
                        if (testToGoal < currentToGoal) {
                            dangerScore *= 0.3; // ゴールに近づく場合は危険度を大幅減少
                        }
                    } else if (goalDistance < 15) {
                        goalPenalty = 0.02; // 中距離でも直線を優先
                    }
                    
                    // 最も近いゾンビが遠い場合もペナルティ軽減
                    if (nearestZombieDistance > HUMAN_AVOIDANCE_RANGE * 2) {
                        goalPenalty *= 0.3; // 安全な場合は直線を強く優先
                    }
                    
                    dangerScore += goalDistance * goalPenalty;
                    
                    if (dangerScore < minDanger) {
                        minDanger = dangerScore;
                        bestOffset = offset;
                    }
                });
                
                point.x += bestOffset.x;
                point.z += bestOffset.z;
            }
            
            return path;
        }

        // ゲームの初期化
        function initGame() {
            console.log('ゲーム初期化開始 - ステージ', currentStage);
            
            // 既存の入口・出口オブジェクトをクリア
            const toRemove = [];
            scene.children.forEach(child => {
                if (child.userData && child.userData.removable) {
                    toRemove.push(child);
                }
            });
            toRemove.forEach(obj => scene.remove(obj));
            
            // 統一エンティティのクリア
            entities.forEach(entity => {
                if (entity.mesh) scene.remove(entity.mesh);
            });
            effects.forEach(effect => {
                if (effect.mesh) scene.remove(effect.mesh);
            });
            clearDebugLines();
            
            // エンティティIDをリセット
            nextEntityId = 1;
            entities = [];
            effects = [];

            // 新しい部屋を生成
            generateEntrancesAndExits();

            // 人の配置（入口エリアからスタート）
            console.log('人を作成中...');
            if (entrances.length > 0) {
                const entrance = entrances[0];
                createHuman(entrance.x, entrance.z);
            }

            // ゾンビの配置（10匹固定）
            console.log('ゾンビを作成中...');
            const zombieCount = 10;
            for (let i = 0; i < zombieCount; i++) {
                const x = (Math.random() - 0.5) * (FIELD_SIZE_X - 4);
                const z = (Math.random() - 0.5) * (FIELD_SIZE_Z - 4);
                createZombie(x, z);
            }

            // 後方互換性配列を更新
            updateCompatibilityArrays();

            gameTime = 0;
            updateHUD();
            // updateDebugInfo(); // デバッグ表示を無効化
            console.log('ゲーム初期化完了:', humans.length, 'humans,', zombies.length, 'zombies');
        }

        // HUDの更新
        function updateHUD() {
            document.getElementById('stageCount').textContent = `ステージ: ${currentStage}`;
            document.getElementById('timer').textContent = `時間: ${Math.floor(gameTime)}s`;
        }

        // ゲーム開始
        function startGame() {
            console.log('ゲーム開始関数呼び出し');
            gameState = 'playing';
            gameRunning = true;
            document.getElementById('gameStatus').style.display = 'none';
            initGame();
            console.log('ゲーム開始完了! 人数:', humans.length, 'ゾンビ数:', zombies.length);
            // updateDebugInfo(); // デバッグ表示を無効化
        }

        // タッチ/クリック処理（マルチタッチ2か所まで制限）
        function handleTouch(event) {
            if (gameState !== 'playing') return;

            event.preventDefault();
            const touches = event.touches || [event];
            
            // マルチタッチを2か所までに制限
            const maxTouches = Math.min(touches.length, 2);

            for (let i = 0; i < maxTouches; i++) {
                const touch = touches[i];
                const rect = renderer.domElement.getBoundingClientRect();
                const x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                const y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

                // レイキャスティングで3D座標を取得
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
                
                const intersect = raycaster.intersectObjects(scene.children.filter(obj => obj.name === 'ground'));
                let point;
                
                if (intersect.length > 0) {
                    point = intersect[0].point;
                } else {
                    // 床との交点を計算
                    const ray = raycaster.ray;
                    const t = -ray.origin.y / ray.direction.y;
                    point = ray.origin.clone().add(ray.direction.clone().multiplyScalar(t));
                }
                
                console.log('タップ位置:', point.x.toFixed(2), point.z.toFixed(2), `(${i+1}/${maxTouches})`);
                createRippleEffect(point.x, point.z);
                affectZombiesInRadius(point.x, point.z, TAP_RADIUS);
            }
        }

        // タップ効果システム
        const tapEffects = {
            'knockdown': {
                duration: ZOMBIE_DOWN_TIME,
                visualEffect: 'tilt',
                canAffect: (entity) => entity.type === 'zombie' &&
                          ['wandering', 'rotating', 'chasing'].includes(entity.state)
            },
            'push': {
                force: 5.0,
                duration: 0.5,
                visualEffect: 'ripple',
                canAffect: (entity) => entity.type === 'zombie'
            }
        };

        // 統一タップ効果処理
        function applyTapEffect(entity, effectType, x, z) {
            const effect = tapEffects[effectType];
            if (!effect || !effect.canAffect(entity)) return false;

            switch (effectType) {
                case 'knockdown':
                    entity.state = 'down';
                    entity.timers.downTimer = effect.duration;
                    entity.movement.direction = Math.random() * Math.PI * 2;
                    entity.timers.wanderTimer = 0;
                    entity.mesh.rotation.z = Math.PI / 4; // 45度傾ける
                    // 後方互換性
                    entity.downTimer = entity.timers.downTimer;
                    entity.direction = entity.movement.direction;
                    entity.wanderTimer = entity.timers.wanderTimer;
                    break;
                case 'push':
                    // 将来のはじき動作用（現在は未実装）
                    console.log('Push effect applied to entity', entity.id);
                    break;
            }
            return true;
        }

        // 範囲内のエンティティに影響を与える
        function affectEntitiesInRadius(x, z, radius, effectType = 'knockdown') {
            // 後方互換性のため、配列も更新
            updateCompatibilityArrays();
            
            let affectedCount = 0;
            entities.forEach(entity => {
                const dx = entity.position.x - x;
                const dz = entity.position.z - z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance <= radius) {
                    if (applyTapEffect(entity, effectType, x, z)) {
                        affectedCount++;
                    }
                }
            });
            
            console.log(`${effectType} effect applied to ${affectedCount} entities`);
            return affectedCount;
        }

        // 後方互換性のための関数
        function affectZombiesInRadius(x, z, radius) {
            return affectEntitiesInRadius(x, z, radius, 'knockdown');
        }

        // 統一衝突判定システム
        function checkCollision(entity1, entity2, distance = CONTACT_DISTANCE) {
            const dx = entity1.position.x - entity2.position.x;
            const dz = entity1.position.z - entity2.position.z;
            const actualDistance = Math.sqrt(dx * dx + dz * dz);
            return actualDistance <= distance;
        }

        // エンティティ間相互作用処理
        function processEntityInteractions() {
            const humans = getHumans();
            const zombies = getZombies();

            humans.forEach(human => {
                if (!human.alive) return;

                zombies.forEach(zombie => {
                    if (zombie.state === 'down') return;

                    if (checkCollision(human, zombie)) {
                        // 人がゾンビに接触した場合の処理
                        human.alive = false;
                        console.log('人が死亡しました（エンティティ', human.id, 'がゾンビ', zombie.id, 'と接触）');
                        checkLoseCondition();
                    }
                });
            });
        }

        // エンティティ距離計算（ヘルパー関数）
        function getEntityDistance(entity1, entity2) {
            const dx = entity1.position.x - entity2.position.x;
            const dz = entity1.position.z - entity2.position.z;
            return Math.sqrt(dx * dx + dz * dz);
        }

        // 最も近いエンティティを見つける
        function findNearestEntity(sourceEntity, targetType, maxDistance = Infinity) {
            const candidates = getEntitiesByType(targetType);
            let nearest = null;
            let nearestDistance = maxDistance;

            candidates.forEach(candidate => {
                if (candidate.id === sourceEntity.id) return; // 自分自身は除外

                const distance = getEntityDistance(sourceEntity, candidate);
                if (distance < nearestDistance) {
                    nearestDistance = distance;
                    nearest = candidate;
                }
            });

            return nearest;
        }

        // デバッグ情報の更新
        function updateDebugInfo() {
            const debugElement = document.getElementById('debugText');
            if (!debugElement) {
                console.log('デバッグ要素が見つかりません');
                return;
            }
            
            let debugText = `ステージ: ${currentStage}<br>`;
            debugText += `ゲーム状態: ${gameState}<br>`;
            debugText += `実行中: ${gameRunning}<br>`;
            debugText += `時間: ${gameTime.toFixed(1)}s<br>`;
            debugText += `人数: ${humans.length}, ゾンビ数: ${zombies.length}<br>`;
            debugText += `出口数: ${exits.length}<br>`;
            
            if (humans.length > 0) {
                const human = humans[0];
                debugText += `人: (${human.x.toFixed(1)}, ${human.z.toFixed(1)}) 生存: ${human.alive}<br>`;
                debugText += `接触タイマー: ${human.contactTimer.toFixed(2)}s<br>`;
            } else {
                debugText += `人: 未作成<br>`;
            }
            
            if (zombies.length > 0) {
                zombies.forEach((zombie, i) => {
                    debugText += `ゾンビ${i+1}: (${zombie.x.toFixed(1)}, ${zombie.z.toFixed(1)}) ${zombie.state}`;
                    if (zombie.state === 'wandering') {
                        debugText += ` 徘徊中`;
                    } else if (zombie.state === 'rotating') {
                        debugText += ` 回転中`;
                    } else if (zombie.state === 'chasing') {
                        debugText += ` 追跡中`;
                    } else if (zombie.state === 'down') {
                        debugText += ` 転倒中`;
                    }
                    debugText += `<br>`;
                });
            } else {
                debugText += `ゾンビ: 未作成<br>`;
            }
            
            debugElement.innerHTML = debugText;
        }

        // ゲームロジックの更新
        function updateGame(deltaTime) {
            if (!gameRunning) return;

            gameTime += deltaTime;
            
            // エンティティ位置同期（後方互換性のため）
            entities.forEach(entity => {
                // 統一プロパティから個別プロパティへ同期
                entity.x = entity.position.x;
                entity.z = entity.position.z;
                entity.speed = entity.movement.speed;
                entity.direction = entity.movement.direction;
                
                // タイマー同期
                if (entity.type === 'zombie') {
                    entity.downTimer = entity.timers.downTimer;
                    entity.wanderTimer = entity.timers.wanderTimer;
                    entity.contactTimer = entity.timers.contactTimer;
                }
                if (entity.type === 'human') {
                    entity.movement.path = entity.currentPath;
                    entity.movement.pathIndex = entity.pathIndex;
                    entity.movement.pathUpdateTimer = entity.timers.pathUpdateTimer;
                    entity.timers.contactTimer = entity.timers.contactTimer;
                }
            });
            
            // 後方互換性配列を更新
            updateCompatibilityArrays();
            
            console.log('ゲーム更新中:', gameTime.toFixed(1), 'deltaTime:', deltaTime.toFixed(3));

            // 人の更新
            humans.forEach(human => {
                if (!human.alive) return;

                // 最も近い出口を確認（動的に変更）
                const nearestExit = findNearestExit(human.x, human.z);
                if (nearestExit !== human.currentTarget) {
                    human.currentTarget = nearestExit;
                    human.targetX = nearestExit.x;
                    human.targetZ = nearestExit.z;
                    console.log('目標変更:', nearestExit);
                }

                // 出口への基本方向
                const goalDx = human.targetX - human.x;
                const goalDz = human.targetZ - human.z;
                const goalDistance = Math.sqrt(goalDx * goalDx + goalDz * goalDz);

                if (goalDistance <= 2.0) {
                    // 出口到達 - 次のステージへ
                    nextStage();
                    return;
                }

                // 経路を定期的に更新（1秒ごと）
                human.pathUpdateTimer += deltaTime;
                if (human.pathUpdateTimer >= 1.0 || human.currentPath.length === 0) {
                    human.currentPath = calculateCurvePath(human.x, human.z, human.targetX, human.targetZ);
                    human.pathIndex = 0;
                    human.pathUpdateTimer = 0;
                    
                    // パス表示をクリアして再描画
                    clearPathLines();
                    
                    // 詳細ログ出力
                    console.log('パス情報:', human.currentPath.map((p, i) => `${i}: (${p.x.toFixed(1)}, ${p.z.toFixed(1)})`).join(', '));
                    
                    // 曲線経路表示（明るい緑）
                    createPathLine(human.currentPath, 0x00ff00);
                    
                    // ウェイポイントマーカー表示（今回は省略）
                    // createWaypointMarkers(human.currentPath);
                    
                    // ゾンビ危険度表示
                    // createDangerZones(); // モバイル向けに無効化
                    
                    console.log('=== 経路更新完了 ===');
                }

                // 緊急回避チェック（移動前）
                let emergencyAvoidance = false;
                let avoidanceDirection = null;
                
                // 最も近いゾンビとの距離をチェック
                zombies.forEach(zombie => {
                    if (zombie.state === 'down') return;
                    
                    const dx = zombie.x - human.x;
                    const dz = zombie.z - human.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    // 緊急回避が必要な距離（より控えめに）
                    const emergencyDistance = CONTACT_DISTANCE * 3;
                    if (distance < emergencyDistance) {
                        emergencyAvoidance = true;
                        // ゾンビから逃げる方向を計算
                        const avoidX = human.x - zombie.x;
                        const avoidZ = human.z - zombie.z;
                        const avoidDist = Math.sqrt(avoidX * avoidX + avoidZ * avoidZ);
                        if (avoidDist > 0) {
                            avoidanceDirection = {
                                x: (avoidX / avoidDist),
                                z: (avoidZ / avoidDist)
                            };
                        }
                    }
                });

                // 緊急回避または通常移動
                if (emergencyAvoidance && avoidanceDirection) {
                    // 緊急回避移動
                    const emergencySpeed = human.speed * 1.5; // 通常より速く
                    const moveX = avoidanceDirection.x * emergencySpeed * deltaTime;
                    const moveZ = avoidanceDirection.z * emergencySpeed * deltaTime;
                    
                    // 境界チェック（16:9比率対応）
                    const newX = human.x + moveX;
                    const newZ = human.z + moveZ;
                    if (Math.abs(newX) < FIELD_SIZE_X/2 - 2 && Math.abs(newZ) < FIELD_SIZE_Z/2 - 2) {
                        human.x = newX;
                        human.z = newZ;
                        human.mesh.position.set(human.x, 1.0, human.z);
                        human.direction = Math.atan2(avoidanceDirection.z, avoidanceDirection.x);
                        console.log('緊急回避移動実行');
                    }
                } else {
                    // 通常の経路に沿って移動
                    if (human.currentPath.length > 1 && human.pathIndex < human.currentPath.length - 1) {
                        const currentWaypoint = human.currentPath[human.pathIndex];
                        const nextWaypoint = human.currentPath[human.pathIndex + 1];
                        
                        const dx = nextWaypoint.x - human.x;
                        const dz = nextWaypoint.z - human.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        // 移動前に安全性をチェック
                        let safeToMove = true;
                        const plannedX = human.x + (dx / distance) * human.speed * deltaTime;
                        const plannedZ = human.z + (dz / distance) * human.speed * deltaTime;
                        
                        zombies.forEach(zombie => {
                            if (zombie.state === 'down') return;
                            const checkDx = zombie.x - plannedX;
                            const checkDz = zombie.z - plannedZ;
                            const checkDistance = Math.sqrt(checkDx * checkDx + checkDz * checkDz);
                            if (checkDistance < CONTACT_DISTANCE * 2) {
                                safeToMove = false;
                            }
                        });
                        
                        if (safeToMove) {
                            // 次のウェイポイントに近づいたら次へ
                            if (distance < 1.0) {
                                human.pathIndex++;
                                console.log(`ウェイポイント${human.pathIndex}に到達`);
                            } else {
                                // ウェイポイントに向かって移動
                                const moveX = (dx / distance) * human.speed * deltaTime;
                                const moveZ = (dz / distance) * human.speed * deltaTime;
                                
                                human.x += moveX;
                                human.z += moveZ;
                                human.mesh.position.set(human.x, 1.0, human.z);
                                
                                // 進行方向を記録
                                human.direction = Math.atan2(dz, dx);
                            }
                        } else {
                            // 危険な移動は停止して経路再計算を促す
                            human.pathUpdateTimer = 1.0; // 即座に再計算
                            console.log('危険な移動を検出、経路再計算');
                        }
                    }
                }

                // ゾンビとの即死判定
                zombies.forEach(zombie => {
                    if (zombie.state === 'down') return;
                    
                    const zombieDx = zombie.x - human.x;
                    const zombieDz = zombie.z - human.z;
                    const zombieDistance = Math.sqrt(zombieDx * zombieDx + zombieDz * zombieDz);
                    
                    if (zombieDistance <= CONTACT_DISTANCE) {
                        human.alive = false;
                        console.log('人が死亡しました（移動中にゾンビと接触）');
                        checkLoseCondition();
                        return;
                    }
                });
            });

            // ゾンビの更新
            zombies.forEach(zombie => {
                if (zombie.state === 'down') {
                    zombie.downTimer -= deltaTime;
                    if (zombie.downTimer <= 0) {
                        zombie.state = 'wandering';
                        zombie.mesh.rotation.z = 0; // 元の向きに戻す
                        zombie.wanderTimer = 0;
                    }
                    return;
                }

                // 最も近い人を探す
                let nearestHuman = null;
                let nearestDistance = Infinity;
                
                humans.forEach(human => {
                    if (!human.alive) return;
                    const dx = human.x - zombie.x;
                    const dz = human.z - zombie.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestHuman = human;
                    }
                });

                if (nearestHuman) {
                    const dx = nearestHuman.x - zombie.x;
                    const dz = nearestHuman.z - zombie.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    // 接触判定（即死）
                    if (distance <= CONTACT_DISTANCE) {
                        nearestHuman.alive = false;
                        console.log('人が死亡しました（ゾンビと接触）');
                        checkLoseCondition();
                        return;
                    }

                    // 状態に応じた行動
                    if (zombie.state === 'wandering') {
                        // ランダム移動
                        zombie.wanderTimer += deltaTime;
                        if (zombie.wanderTimer >= 2.0) {
                            zombie.direction = Math.random() * Math.PI * 2;
                            zombie.wanderTimer = 0;
                        }
                        
                        // 移動
                        const moveX = Math.cos(zombie.direction) * zombie.speed * 0.5 * deltaTime;
                        const moveZ = Math.sin(zombie.direction) * zombie.speed * 0.5 * deltaTime;
                        zombie.x += moveX;
                        zombie.z += moveZ;
                        zombie.mesh.position.set(zombie.x, 1.0, zombie.z);
                        
                        // 人が検知範囲内にいるか確認
                        if (distance <= ZOMBIE_DETECTION_RANGE) {
                            zombie.state = 'rotating';
                            zombie.targetDirection = Math.atan2(dz, dx);
                            
                            // 最短回転方向を決定
                            const angleDiff = zombie.targetDirection - zombie.direction;
                            const normalizedDiff = ((angleDiff + Math.PI) % (2 * Math.PI)) - Math.PI;
                            zombie.rotationDirection = normalizedDiff > 0 ? 1 : -1;
                        }
                    } else if (zombie.state === 'rotating') {
                        // 目標方向に回転
                        zombie.direction += zombie.rotationDirection * ZOMBIE_ROTATION_SPEED * deltaTime;
                        
                        // 目標方向に到達したか確認
                        const angleDiff = zombie.targetDirection - zombie.direction;
                        const normalizedDiff = ((angleDiff + Math.PI) % (2 * Math.PI)) - Math.PI;
                        
                        if (Math.abs(normalizedDiff) < 0.1) {
                            zombie.state = 'chasing';
                            zombie.direction = zombie.targetDirection;
                        }
                    } else if (zombie.state === 'chasing') {
                        // 人の現在位置に向かって最短距離で移動
                        const currentDirection = Math.atan2(dz, dx);
                        zombie.direction = currentDirection;
                        
                        if (distance > 0.3) {
                            const moveX = Math.cos(zombie.direction) * zombie.speed * deltaTime;
                            const moveZ = Math.sin(zombie.direction) * zombie.speed * deltaTime;
                            
                            zombie.x += moveX;
                            zombie.z += moveZ;
                            zombie.mesh.position.set(zombie.x, 1.0, zombie.z);
                        }
                        
                        // 人が遠くに行ったらランダム移動に戻る
                        if (distance > ZOMBIE_DETECTION_RANGE) {
                            zombie.state = 'wandering';
                            zombie.wanderTimer = 0;
                        }
                    }
                } else {
                    // 人がいない場合はランダム移動
                    zombie.state = 'wandering';
                    zombie.wanderTimer += deltaTime;
                    if (zombie.wanderTimer >= 2.0) {
                        zombie.direction = Math.random() * Math.PI * 2;
                        zombie.wanderTimer = 0;
                    }
                    
                    // 移動
                    const moveX = Math.cos(zombie.direction) * zombie.speed * 0.5 * deltaTime;
                    const moveZ = Math.sin(zombie.direction) * zombie.speed * 0.5 * deltaTime;
                    zombie.x += moveX;
                    zombie.z += moveZ;
                    zombie.mesh.position.set(zombie.x, 1.0, zombie.z);
                }
            });

            // エフェクトの更新
            effects = effects.filter(effect => {
                effect.life -= deltaTime;
                const alpha = effect.life / effect.maxLife;
                effect.mesh.material.opacity = alpha * 0.6;
                
                if (effect.life <= 0) {
                    scene.remove(effect.mesh);
                    return false;
                }
                return true;
            });

            // デバッグライン表示
            clearDebugLines();
            
            // 人の進行方向ライン
            humans.forEach(human => {
                if (!human.alive) return;
                const lineLength = 3;
                const endX = human.x + Math.cos(human.direction) * lineLength;
                const endZ = human.z + Math.sin(human.direction) * lineLength;
                createDebugLine(human.x, human.z, endX, endZ, 0x00aaff);
                
                // 現在のウェイポイントへのライン
                if (human.currentPath.length > 0 && human.pathIndex < human.currentPath.length) {
                    const targetWaypoint = human.currentPath[human.pathIndex];
                    createDebugLine(human.x, human.z, targetWaypoint.x, targetWaypoint.z, 0x00ff00);
                }
            });
            
            // ゾンビの進行方向ライン
            zombies.forEach(zombie => {
                if (zombie.state === 'down') return;
                const lineLength = 3;
                const endX = zombie.x + Math.cos(zombie.direction) * lineLength;
                const endZ = zombie.z + Math.sin(zombie.direction) * lineLength;
                
                let color = 0xff0000; // 基本色（赤）
                if (zombie.state === 'wandering') color = 0xff4444; // 徘徊中（薄い赤）
                if (zombie.state === 'rotating') color = 0xffaa00; // 回転中（オレンジ）
                if (zombie.state === 'chasing') color = 0xff0088; // 追跡中（ピンク）
                
                createDebugLine(zombie.x, zombie.z, endX, endZ, color);
            });

            // 個別プロパティから統一プロパティへ逆同期
            entities.forEach(entity => {
                // 位置の逆同期
                entity.position.x = entity.x;
                entity.position.z = entity.z;
                entity.movement.speed = entity.speed;
                entity.movement.direction = entity.direction;
                
                // タイマーの逆同期
                if (entity.type === 'zombie') {
                    entity.timers.downTimer = entity.downTimer;
                    entity.timers.wanderTimer = entity.wanderTimer;
                    entity.timers.contactTimer = entity.contactTimer;
                }
                if (entity.type === 'human') {
                    entity.movement.path = entity.currentPath;
                    entity.movement.pathIndex = entity.pathIndex;
                    entity.movement.pathUpdateTimer = entity.pathUpdateTimer;
                    entity.timers.contactTimer = entity.contactTimer;
                }
            });

            // 危険ゾーンをリアルタイム更新
            // createDangerZones(); // モバイル向けに無効化

            updateHUD();
            // updateDebugInfo(); // デバッグ表示を無効化
        }

        // 次のステージへ
        function nextStage() {
            // 到達した出口の情報を記録
            const human = humans[0];
            const reachedExit = findNearestExit(human.x, human.z);
            if (reachedExit) {
                // 壁上での位置を計算
                let position;
                if (reachedExit.wall === 'north' || reachedExit.wall === 'south') {
                    position = reachedExit.x;
                } else {
                    position = reachedExit.z;
                }
                
                lastExitInfo = {
                    wall: reachedExit.wall,
                    position: position
                };
                console.log('出口情報記録:', lastExitInfo);
            }
            
            currentStage++;
            console.log('ステージ', currentStage, 'へ移行');
            
            gameState = 'win';
            gameRunning = false;
            document.getElementById('statusText').textContent = `ステージ${currentStage-1}クリア！`;
            document.getElementById('startButton').textContent = `次のステージ`;
            document.getElementById('gameStatus').style.display = 'block';
        }

        // 勝利条件チェック（廃止）
        function checkWinCondition() {
            // nextStage()に置き換え
        }

        // 敗北条件チェック
        function checkLoseCondition() {
            const aliveHumans = humans.filter(h => h.alive);
            if (aliveHumans.length === 0) {
                gameLose();
            }
        }

        // ゲーム勝利
        function gameWin() {
            gameState = 'win';
            gameRunning = false;
            document.getElementById('statusText').textContent = 'ステージクリア！';
            document.getElementById('startButton').textContent = '次のステージ';
            document.getElementById('gameStatus').style.display = 'block';
        }

        // ゲーム敗北
        function gameLose() {
            gameState = 'lose';
            gameRunning = false;
            document.getElementById('statusText').textContent = 'ゲームオーバー';
            document.getElementById('startButton').textContent = 'リトライ';
            document.getElementById('gameStatus').style.display = 'block';
        }

        // ウィンドウリサイズ処理
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // アニメーションループ
        let lastTime = 0;
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            updateGame(deltaTime);
            
            // ゲーム開始前でもデバッグ情報を更新
            if (gameState === 'menu') {
                // updateDebugInfo(); // デバッグ表示を無効化
            }
            
            renderer.render(scene, camera);
        }

        // 初期化
        function init() {
            console.log('初期化開始');
            initCamera();
            initScene();
            initRenderer();

            // 初期デバッグ情報の表示
            // updateDebugInfo(); // デバッグ表示を無効化

            // イベントリスナーの追加
            window.addEventListener('resize', onWindowResize);
            
            // タッチイベント
            renderer.domElement.addEventListener('touchstart', handleTouch, { passive: false });
            renderer.domElement.addEventListener('touchmove', handleTouch, { passive: false });
            
            // マウスイベント（PC用）
            renderer.domElement.addEventListener('mousedown', handleTouch);

            // スタートボタンのイベントリスナー
            const startButton = document.getElementById('startButton');
            if (startButton) {
                startButton.addEventListener('click', startGame);
                console.log('スタートボタンイベント設定完了');
            } else {
                console.error('スタートボタンが見つかりません');
            }

            console.log('初期化完了、アニメーション開始');
            animate(0);
            
            // 自動でゲーム開始
            setTimeout(() => {
                console.log('自動ゲーム開始');
                startGame();
            }, 1000);
        }

        // ページ読み込み完了後に初期化
        window.addEventListener('load', init);
    </script>
</body>
</html>