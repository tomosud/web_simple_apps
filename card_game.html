<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>メンコゲーム - 加速度センサー</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
            transition: background-color 0.1s ease;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
            max-width: 200px;
        }
        
        #gameCanvas {
            display: block;
        }
        
        #permissionDialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        button {
            background: #007AFF;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px;
        }
        
        button:hover {
            background: #0056b3;
        }
    </style>
</head>
<body>
    <div id="permissionDialog">
        <h2>メンコゲーム</h2>
        <p>加速度センサーを使用してメンコを投げます</p>
        <button onclick="requestSensorPermission()">ゲーム開始</button>
    </div>
    
    <div id="info">
        <div>Z軸加速度: <span id="zAccel">0.00</span></div>
        <div>カード距離: <span id="cardDistance">0</span></div>
        <div>状態: <span id="gameState">待機中</span></div>
        <div>投げ速度: <span id="throwSpeed">0</span></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ゲーム変数
        let scene, camera, renderer, playerCard, floor;
        let impactEffects = []; // 衝撃エフェクト
        let accelerationData = { x: 0, y: 0, z: 0 };
        let orientationData = { alpha: 0, beta: 0, gamma: 0 };
        let cardPosition = { x: 0, y: 0, z: 0 };
        let cardRotation = { x: 0, y: 0, z: 0 };
        let isThrown = false;
        let throwVelocity = { x: 0, y: 0, z: 0 };
        let throwRotationVelocity = { x: 0, y: 0, z: 0 };
        const THROW_THRESHOLD = 50;
        const FLOOR_Z = -30; // 床の位置（奥行き方向）
        const CARD_SIZE_MULTIPLIER = 1.5;
        const CARD_WIDTH_RATIO = 0.9; // カードを90%の幅に
        
        // テクスチャ
        let frontTexture, backTexture;
        
        // Three.js初期化
        function initThreeJS() {
            // シーン作成
            scene = new THREE.Scene();
            
            // カメラ作成
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            // レンダラー作成
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000);
            document.body.appendChild(renderer.domElement);
            renderer.domElement.id = 'gameCanvas';
            
            // ライト追加
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            // プレイヤーカード作成
            createPlayerCard();
            
            // 床作成
            createFloor();
            
            // アニメーションループ開始
            animate();
        }
        
        function createPlayerCard() {
            // プレイヤーカードのジオメトリ（90%の幅）
            const aspect = window.innerWidth / window.innerHeight;
            const cardWidth = 3 * aspect * CARD_SIZE_MULTIPLIER * CARD_WIDTH_RATIO;
            const cardHeight = 3 * CARD_SIZE_MULTIPLIER;
            
            const geometry = new THREE.PlaneGeometry(cardWidth, cardHeight);
            const material = new THREE.MeshLambertMaterial({
                map: frontTexture,
                side: THREE.DoubleSide
            });
            
            playerCard = new THREE.Mesh(geometry, material);
            playerCard.position.set(0, 0, 0);
            scene.add(playerCard);
        }
        
        function createFloor() {
            // 床の作成（奥行き方向に配置）
            const floorGeometry = new THREE.PlaneGeometry(100, 100);
            const floorMaterial = new THREE.MeshLambertMaterial({
                color: 0x333333,
                transparent: true,
                opacity: 0.5
            });
            floor = new THREE.Mesh(floorGeometry, floorMaterial);
            // 床を縦に立てて奥行き方向に配置
            floor.position.set(0, 0, FLOOR_Z);
            scene.add(floor);
        }
        
        function updateCard() {
            if (!isThrown) {
                // Z軸加速度に基づいてカードの位置を更新
                const zAccel = Math.abs(accelerationData.z);
                cardPosition.z = -zAccel * 0.1; // 近づいたり遠ざかったり
                
                // 角度センサーで視差効果（デバイスの傾きでカメラを移動）
                updateCameraWithOrientation();
                
                // 閾値チェック
                if (zAccel > THROW_THRESHOLD) {
                    throwCard();
                }
                
                document.getElementById('cardDistance').textContent = cardPosition.z.toFixed(2);
                document.getElementById('gameState').textContent = '準備中';
            } else {
                // 投げられた後の物理演算
                cardPosition.x += throwVelocity.x;
                cardPosition.y += throwVelocity.y;
                cardPosition.z += throwVelocity.z;
                
                cardRotation.x += throwRotationVelocity.x;
                cardRotation.y += throwRotationVelocity.y;
                cardRotation.z += throwRotationVelocity.z;
                
                // 重力効果
                throwVelocity.y -= 0.01;
                
                // 空気抵抗
                throwVelocity.x *= 0.99;
                throwVelocity.y *= 0.99;
                throwVelocity.z *= 0.99;
                
                // 回転の減衰
                throwRotationVelocity.x *= 0.98;
                throwRotationVelocity.y *= 0.98;
                throwRotationVelocity.z *= 0.98;
                
                document.getElementById('cardDistance').textContent = cardPosition.z.toFixed(2);
                document.getElementById('gameState').textContent = '投げ中';
                
                // 床に当たったかチェック（奥行き方向）
                if (cardPosition.z <= FLOOR_Z) {
                    hitFloor();
                }
            }
            
            // プレイヤーカードの位置と回転を適用
            playerCard.position.set(cardPosition.x, cardPosition.y, cardPosition.z);
            playerCard.rotation.set(cardRotation.x, cardRotation.y, cardRotation.z);
            
            // 衝撃エフェクトの更新
            updateImpactEffects();
        }
        
        function throwCard() {
            isThrown = true;
            
            // 投げる速度を設定（加速度に基づく）
            throwVelocity.x = (accelerationData.x || 0) * 0.02;
            throwVelocity.y = (accelerationData.y || 0) * 0.02;
            throwVelocity.z = -Math.abs(accelerationData.z) * 0.05; // 奥に向かって
            
            // 回転速度を設定
            throwRotationVelocity.x = (Math.random() - 0.5) * 0.3;
            throwRotationVelocity.y = (Math.random() - 0.5) * 0.3;
            throwRotationVelocity.z = (Math.random() - 0.5) * 0.2;
            
            document.getElementById('gameState').textContent = '投げました！';
        }
        
        function hitFloor() {
            // 投げ速度を計算（勢い）
            const speed = Math.sqrt(
                throwVelocity.x * throwVelocity.x +
                throwVelocity.y * throwVelocity.y +
                throwVelocity.z * throwVelocity.z
            );
            
            // 衝撃エフェクト作成（勢いに応じた強弱）
            createImpactEffect(cardPosition.x, cardPosition.z, speed);
            
            document.getElementById('throwSpeed').textContent = speed.toFixed(2);
            document.getElementById('gameState').textContent = '床に衝突！';
            
            // カードをリセット
            setTimeout(() => {
                resetCard();
            }, 1000);
        }
        
        function resetCard() {
            // カードを元の位置に戻す
            cardPosition = { x: 0, y: 0, z: 0 };
            cardRotation = { x: 0, y: 0, z: 0 };
            throwVelocity = { x: 0, y: 0, z: 0 };
            throwRotationVelocity = { x: 0, y: 0, z: 0 };
            isThrown = false;
            
            // カメラも元の位置に戻す
            camera.position.set(0, 0, 5);
            camera.lookAt(0, 0, 0);
            
            document.getElementById('gameState').textContent = 'リセット完了';
        }
        
        function updateImpactEffects() {
            for (let i = impactEffects.length - 1; i >= 0; i--) {
                const effect = impactEffects[i];
                const userData = effect.userData;
                
                // 勢いに応じた拡大速度でエフェクトを拡大
                effect.scale.x += userData.expansionSpeed;
                effect.scale.z += userData.expansionSpeed;
                
                // 段階的に透明度を下げる
                effect.material.opacity -= 0.015;
                
                // 最大拡大サイズに達するか透明になったら削除
                if (effect.scale.x >= userData.maxExpansion || effect.material.opacity <= 0) {
                    scene.remove(effect);
                    impactEffects.splice(i, 1);
                }
            }
        }
        
        function createImpactEffect(x, z, speed) {
            // 勢いに応じたエフェクトサイズ
            const baseSize = 1;
            const maxSize = 5;
            const effectSize = Math.min(baseSize + speed * 0.5, maxSize);
            
            // 勢いに応じた色の強さ
            const intensity = Math.min(speed / 2, 1);
            const red = Math.floor(255 * intensity);
            const green = Math.floor(215 * intensity);
            const blue = Math.floor(0 * intensity);
            
            // 衝撃エフェクトの輪っか
            const geometry = new THREE.RingGeometry(effectSize * 0.3, effectSize, 16);
            const material = new THREE.MeshBasicMaterial({
                color: (red << 16) | (green << 8) | blue,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(geometry, material);
            ring.position.set(x, 0, FLOOR_Z + 0.1);
            // 床が縦なので輪っかも縦向きに
            ring.rotation.y = 0;
            
            // エフェクトデータを保存
            ring.userData = {
                initialSize: effectSize,
                maxExpansion: effectSize * 3,
                expansionSpeed: speed * 0.1 + 0.1
            };
            
            impactEffects.push(ring);
            scene.add(ring);
        }
        
        function updateCameraWithOrientation() {
            // 角度センサーの値を使ってカメラの位置を微調整（視差効果）
            const maxOffset = 2; // カメラの最大移動距離
            
            // γ（左右の傾き）でX軸移動
            const xOffset = (orientationData.gamma / 90) * maxOffset;
            // β（前後の傾き）でY軸移動
            const yOffset = (orientationData.beta / 180) * maxOffset;
            
            // カメラ位置を更新（滑らかに移動）
            camera.position.x += (xOffset - camera.position.x) * 0.1;
            camera.position.y += (yOffset - camera.position.y) * 0.1;
            
            // カメラを常にカードの方向を向かせる
            camera.lookAt(cardPosition.x, cardPosition.y, cardPosition.z);
        }
        
        function updateBackgroundColor() {
            // 背景色を黒に固定
            document.body.style.backgroundColor = 'rgb(0, 0, 0)';
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            updateCard();
            updateBackgroundColor();
            
            renderer.render(scene, camera);
        }
        
        // センサー許可要求
        function requestSensorPermission() {
            if (typeof DeviceMotionEvent !== 'undefined' &&
                typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            // 角度センサーの許可も要求
                            if (typeof DeviceOrientationEvent !== 'undefined' &&
                                typeof DeviceOrientationEvent.requestPermission === 'function') {
                                DeviceOrientationEvent.requestPermission()
                                    .then(orientationState => {
                                        startGame();
                                    })
                                    .catch(console.error);
                            } else {
                                startGame();
                            }
                        } else {
                            alert('センサーアクセスが許可されませんでした');
                        }
                    })
                    .catch(console.error);
            } else {
                // Android等
                startGame();
            }
        }
        
        function startGame() {
            // 許可ダイアログを隠す
            document.getElementById('permissionDialog').style.display = 'none';
            
            // テクスチャを読み込んでからThree.js初期化
            loadTextures();
            
            // センサーイベントリスナー追加
            window.addEventListener('devicemotion', handleMotion);
            window.addEventListener('deviceorientation', handleOrientation);
            
            document.getElementById('gameState').textContent = 'ゲーム開始';
        }
        
        function loadTextures() {
            const textureLoader = new THREE.TextureLoader();
            let loadedCount = 0;
            
            // 表面テクスチャ
            frontTexture = textureLoader.load('assets/card01.png',
                function(texture) {
                    console.log('表面テクスチャ読み込み成功');
                    loadedCount++;
                    if (loadedCount === 2) initThreeJS();
                },
                undefined,
                function(error) {
                    console.log('表面テクスチャ読み込み失敗:', error);
                }
            );
            
            // 裏面テクスチャ
            backTexture = textureLoader.load('assets/card02.png',
                function(texture) {
                    console.log('裏面テクスチャ読み込み成功');
                    loadedCount++;
                    if (loadedCount === 2) initThreeJS();
                },
                undefined,
                function(error) {
                    console.log('裏面テクスチャ読み込み失敗:', error);
                }
            );
        }
        
        function handleMotion(event) {
            const acc = event.accelerationIncludingGravity || event.acceleration;
            
            if (acc && acc.x !== null && acc.y !== null && acc.z !== null) {
                accelerationData.x = acc.x || 0;
                accelerationData.y = acc.y || 0;
                accelerationData.z = acc.z || 0;
                
                document.getElementById('zAccel').textContent = accelerationData.z.toFixed(2);
            }
        }
        
        function handleOrientation(event) {
            orientationData.alpha = event.alpha || 0; // Z軸回転
            orientationData.beta = event.beta || 0;   // X軸回転（前後の傾き）
            orientationData.gamma = event.gamma || 0; // Y軸回転（左右の傾き）
            
            // デバッグ表示を更新
            document.getElementById('gamma').textContent = orientationData.gamma.toFixed(1);
            document.getElementById('beta').textContent = orientationData.beta.toFixed(1);
        }
        
        // ウィンドウリサイズ対応
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
        
        // ページ読み込み完了時に自動的に許可要求
        window.addEventListener('load', () => {
            // 少し遅延してから自動で許可要求
            setTimeout(() => {
                if (document.getElementById('permissionDialog').style.display !== 'none') {
                    // iOSの場合は手動でボタンを押す必要がある
                    if (typeof DeviceMotionEvent !== 'undefined' && 
                        typeof DeviceMotionEvent.requestPermission === 'function') {
                        // iOSの場合はユーザー操作が必要
                        return;
                    } else {
                        // Androidの場合は自動実行
                        requestSensorPermission();
                    }
                }
            }, 1000);
        });
    </script>
</body>
</html>